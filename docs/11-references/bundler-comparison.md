# 打包工具选型指南：为什么我们选了“偏科生” esbuild？

在前端工程化领域，没有绝对“最强”的工具，只有最适合场景的工具。本文对比三大主流打包器，解释为什么 VS Code 插件开发偏爱 esbuild。

## 1. 三大天王对比

| 特性 | **Webpack** (老大哥) | **Rollup** (学院派) | **esbuild** (闪电侠) |
| :--- | :--- | :--- | :--- |
| **速度** | 🐢 慢 (JS编写) | 🐇 中等 (JS编写) | ⚡ **极快** (Go编写，快10-100倍) |
| **兼容性** | 🌟 **最强** (啥都能吃) | ⭐ 一般 (偏爱ESM) | ⚠️ **严格** (偏爱ESM，对CJS有限制) |
| **配置难度** | 🤯 地狱级 | 🙂 中等 | 😍 **傻瓜级** |
| **产物优化** | 🛠️ 代码分割强 | 🌳 Tree Shaking 最好 | 📉 压缩率略低但够用 |
| **主要场景** | 大型 Web 应用 (React/Vue) | JS 类库/框架开发 | 工具链、插件、Vite底层 |

## 2. 为什么说 esbuild "不够强"？

你提到的“不认识老大哥（CommonJS）”，其实是 esbuild 的设计哲学决定的：**为了速度，牺牲部分动态性。**

*   **Webpack** 为了兼容所有奇怪的写法（比如动态 `require`、各种混用的模块规范），内部实现了一套非常复杂的运行时（Runtime）和加载器（Loader）机制。这让它非常强大，但也非常慢且臃肿。
*   **esbuild** 选择了一条“纯粹”的路：它假设你的代码是符合现代标准的。遇到不规范的 CommonJS 导出（比如直接导出函数），它不会像 Webpack 那样去猜或注入大量辅助代码，而是选择直接报错或按照标准处理。

**这不是能力问题，是取舍问题。**

## 3. 为什么不换用 Webpack？

既然 Webpack 兼容性最好，为什么现在的 VS Code 插件模板（以及 Vite 等新一代工具）都默认用 esbuild？

1.  **开发体验 (DX)**：
    *   Webpack 打包一次可能要 5-10 秒。
    *   esbuild 只要 0.1 秒。
    *   在开发插件时，你改一行代码想看效果，0.1 秒和 10 秒的体验是天壤之别。
2.  **配置维护**：
    *   配置 Webpack 支持 TypeScript、压缩、SourceMap 可能需要写几百行配置，安装十几个 loader。
    *   esbuild 开箱即用，几十行代码搞定。
3.  **插件场景特殊性**：
    *   VS Code 插件运行在 Node.js 环境，对浏览器兼容性要求不高，不需要 Webpack 那些处理 CSS/图片/旧浏览器的复杂功能。

## 4. 有没有“更好”的工具？

如果非要找一个既快又兼容性好的：

*   **Rspack (Rust-based Webpack)**：字节跳动开源的。它用 Rust 重写了 Webpack。
    *   **优点**：兼容 Webpack 配置和生态，同时拥有接近 esbuild 的速度。
    *   **缺点**：相对较新，生态还在完善中。对于简单的插件项目，引入它可能有点“杀鸡用牛刀”。

## 5. 结论

**esbuild 并不是“不够强”，而是“偏科”。**
它的特长是**极致的速度**和**标准化的处理**。

我们在项目中遇到的 `TypeError`，其实是 esbuild 在倒逼我们写出更规范的代码（使用 `import = require`）。这长远来看是件好事，让代码更健壮，而不是依赖工具的“黑魔法”去填坑。
